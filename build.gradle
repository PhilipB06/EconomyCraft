plugins {
    id "dev.architectury.loom" version "1.13.467" apply false
    id "architectury-plugin" version "3.4.162"
    id "com.gradleup.shadow" version "9.3.1" apply false
}

architectury {
    minecraft = project.minecraft_version
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.mod_version
}

subprojects {
    apply plugin: "dev.architectury.loom"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    base {
        def mcVer = (rootProject.findProperty("minecraft_version") ?: rootProject.minecraft_version)
        archivesName = "${rootProject.archives_name}-${project.name}-${rootProject.mod_version}_${mcVer}"
    }

    tasks.withType(Jar).configureEach { archiveVersion = "" }

    tasks.named("remapJar", RemapJarTask).configure {
        input.set(tasks.named("jar").flatMap { it.archiveFile })
        archiveVersion = ""
    }

    repositories {
        maven { url "https://maven.fabricmc.net/" }
        maven { url "https://maven.architectury.dev/" }
        mavenCentral()
    }

    loom {
        silentMojangMappingsLicense()
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    tasks.withType(JavaCompile).configureEach { options.release = 17 }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = base.archivesName.get()
                from components.java
            }
        }
        repositories { /* leer gelassen */ }
    }

}

// ---- TARGET RESOLVER
ext.resolveMcTarget = { String mcStr ->
    def t = ext.mcTargets.find { it.mc == mcStr }
    if (!t) throw new GradleException("No mcTarget for minecraft_version='$mcStr'")
    return t
}

// ---- TASK NAME VERSION
ext.mcTaskVer = { String v ->
    def parts = v.tokenize('.')
    if (parts.size() < 3) return v
    def major = parts[0] as int
    def minor = parts[1] as int
    def patch = parts[2] as int
    return "${major}.${minor}.${String.format('%02d', patch)}"
}

// ---- BUILD TARGETS
ext.mcTargets = [
        [ mc: "1.20.1", fabricApi: "0.92.5+1.20.1", architecturyVer: "9.2.14", yarnBuild: "build.1" ],
]

// ---- Build per version via external gradlew
import net.fabricmc.loom.task.RemapJarTask
import org.gradle.internal.os.OperatingSystem
def gradleWrapper = OperatingSystem.current().isWindows() ? "gradlew.bat" : "./gradlew"

ext.mcTargets.each { t ->
    def mcTask = ext.mcTaskVer(t.mc)

    // Fabric only
    def buildFabricTask = tasks.register("buildFabric_${mcTask}", Exec) {
        workingDir rootProject.projectDir
        commandLine gradleWrapper,
                "--no-daemon",
                "-Pfilter_platforms=fabric",
                "-Pminecraft_version=${t.mc}",
                "-Pfabric_api_version=${t.fabricApi}",
                "-Parchitectury_version_plain=${t.architecturyVer}",
                "-Pyarn_build=${t.yarnBuild ?: 'build.1'}",
                ":fabric:clean", ":fabric:build"
    }

    tasks.register("buildAndCopyFabricJars_${mcTask}") {
        group = "build/fabric"
        description = "Build and copy Fabric Jar for MC ${t.mc}"
        dependsOn buildFabricTask
        doLast {
            def libsDir = file("${rootProject.projectDir}/fabric/build/libs")
            if (!libsDir.exists()) {
                throw new GradleException("Libs dir not found: ${libsDir}")
            }

            def builtJars = libsDir.listFiles().findAll { File f ->
                f.name.endsWith(".jar") &&
                        !f.name.endsWith("-sources.jar") &&
                        !f.name.contains("dev-shadow")
            }
            if (builtJars.isEmpty()) {
                throw new GradleException("No built jars found in ${libsDir}")
            }

            def buildOut = file("${rootProject.projectDir}/build/fabric/${t.mc}")
            copy {
                from builtJars
                into buildOut
            }

            def localModsDir = file("${rootProject.projectDir}/local_servers/fabric/${t.mc}/mods")
            if (!localModsDir.exists()) {
                println "local_servers/fabric/${t.mc}/mods not found â€“ skipped local deploy."
                return
            }

            localModsDir.listFiles()?.findAll { File f ->
                f.name.endsWith(".jar") &&
                        f.name.toLowerCase().contains(rootProject.archives_name.toString().toLowerCase())
            }?.each { it.delete() }

            copy {
                from builtJars
                into localModsDir
            }

            println "Deployed Fabric ${t.mc} jar to ${buildOut} and ${localModsDir}"
        }
    }

    tasks.register("runLocalFabric_${mcTask}", Exec) {
        group = "run/fabric"
        description = "Build, deploy and run local Fabric server for MC ${t.mc}"
        dependsOn "buildAndCopyFabricJars_${mcTask}"

        workingDir "$rootProject.projectDir/local_servers/fabric/${t.mc}"
        // java -Xmx4G -jar server.jar nogui
        commandLine "java", "-Xmx4G", "-jar", "server.jar", "nogui"
    }

}

// Convenience task: build everything
tasks.register("buildAll") {
    group = "build"
    description = "Build all Fabric targets"
    dependsOn tasks.matching { it.name.startsWith("buildAndCopyFabricJars_") }
}

tasks.register("buildAllFabric") {
    group = "build"
    description = "Build all Fabric targets"
    dependsOn tasks.matching { it.name.startsWith("buildAndCopyFabricJars_") }
}
